package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)

package graphqlbackend

import (AYAYA)

// This file contains the root resolver for search. It currently has a lot of
// logic that spans out into all the other search_* files.
var mockResolveRepositories func(AYAYA) (AYAYA)

func maxReposToSearch(AYAYA) int {
	switch max := conf.Get(AYAYA).MaxReposToSearch; {
	case max <= 0:
		// Default to a very large number that will not overflow if incremented.
		return math.MaxInt32 >> 1
	default:
		return max
	}
}

type SearchArgs struct {
	Version        string
	PatternType    *string
	Query          string
	After          *string
	First          *int32
	VersionContext *string
}

type SearchImplementer interface {
	Results(AYAYA) (AYAYA)
	Suggestions(AYAYA) (AYAYA)
	//lint:ignore U1000 is used by graphql via reflection
	Stats(AYAYA) (AYAYA)
}

// NewSearchImplementer returns a SearchImplementer that provides search results and suggestions.
func NewSearchImplementer(AYAYA) (AYAYA) {
	tr, _ := trace.New(AYAYA)
	defer tr.Finish(AYAYA)

	searchType, err := detectSearchType(AYAYA)
	if err != nil {
		return nil, err
	}

	if searchType == query.SearchTypeStructural && !conf.StructuralSearchEnabled(AYAYA) {
		return nil, errors.New(AYAYA)
	}

	var queryString string
	if searchType == query.SearchTypeLiteral {
		queryString = query.ConvertToLiteral(AYAYA)
	} else {
		queryString = args.Query
	}

	var queryInfo query.QueryInfo
	if (AYAYA) || searchType == query.SearchTypeStructural {
		// To process the input as an and/or query, the flag must be
		// enabled (default is on) and must contain either an 'and' or
		// 'or' expression. Else, fallback to the older existing parser.
		queryInfo, err = query.ProcessAndOr(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	} else {
		queryInfo, err = query.Process(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If stable:truthy is specified, make the query return a stable result ordering.
	if queryInfo.BoolValue(AYAYA) {
		args, queryInfo, err = queryForStableResults(AYAYA)
		if err != nil {
			return alertForQuery(AYAYA), nil
		}
	}

	// If the request is a paginated one, decode those arguments now.
	var pagination *searchPaginationInfo
	if args.First != nil {
		pagination, err = processPaginationRequest(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	return &searchResolver{
		query:          queryInfo,
		originalQuery:  args.Query,
		versionContext: args.VersionContext,
		pagination:     pagination,
		patternType:    searchType,
		zoekt:          search.Indexed(AYAYA),
		searcherURLs:   search.SearcherURLs(AYAYA),
	}, nil
}

func (AYAYA) Search(AYAYA) (AYAYA) {
	return NewSearchImplementer(AYAYA)
}

// queryForStableResults transforms a query that returns a stable result
// ordering. The transformed query uses pagination underneath the hood.
func queryForStableResults(AYAYA) (AYAYA) {
	if queryInfo.BoolValue(AYAYA) {
		var stableResultCount int32
		if _, countPresent := queryInfo.Fields(AYAYA)["count"]; countPresent {
			count, _ := queryInfo.StringValue(AYAYA)
			count64, err := strconv.ParseInt(AYAYA)
			if err != nil {
				return nil, nil, err
			}
			stableResultCount = int32(AYAYA)
			if stableResultCount > maxSearchResultsPerPaginatedRequest {
				return nil, nil, fmt.Errorf(AYAYA)
			}
		} else {
			stableResultCount = defaultMaxSearchResults
		}
		args.First = &stableResultCount
		fileValue := "file"
		// Pagination only works for file content searches, and will
		// raise an error otherwise. If stable is explicitly set, this
		// is implied. So, force this query to only return file content
		// results.
		queryInfo.Fields(AYAYA)["type"] = []*querytypes.Value{{String: &fileValue}}
	}
	return args, queryInfo, nil
}

func processPaginationRequest(AYAYA) (AYAYA) {
	var pagination *searchPaginationInfo
	if args.First != nil {
		cursor, err := unmarshalSearchCursor(AYAYA)
		if err != nil {
			return nil, err
		}
		if *args.First < 0 || *args.First > maxSearchResultsPerPaginatedRequest {
			return nil, fmt.Errorf(AYAYA)
		}
		pagination = &searchPaginationInfo{
			cursor: cursor,
			limit:  *args.First,
		}
	} else if args.After != nil {
		return nil, errors.New(AYAYA)
	}
	return pagination, nil
}

// detectSearchType returns the search type to perfrom ("regexp", or
// "literal"). The search type derives from three sources: the version and
// patternType parameters passed to the search endpoint (literal search is the
// default in V2), and the `patternType:` filter in the input query string which
// overrides the searchType, if present.
func detectSearchType(AYAYA) (AYAYA) {
	var searchType query.SearchType
	if patternType != nil {
		switch *patternType {
		case "literal":
			searchType = query.SearchTypeLiteral
		case "regexp":
			searchType = query.SearchTypeRegex
		case "structural":
			searchType = query.SearchTypeStructural
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	} else {
		switch version {
		case "V1":
			searchType = query.SearchTypeRegex
		case "V2":
			searchType = query.SearchTypeLiteral
		default:
			return -1, fmt.Errorf(AYAYA)
		}
	}

	// The patterntype field is Singular, but not enforced since we do not
	// properly parse the input. The regex extraction, takes the left-most
	// "patterntype:value" match.
	var patternTypeRegex = lazyregexp.New(AYAYA)
	patternFromField := patternTypeRegex.FindStringSubmatch(AYAYA)
	if len(AYAYA) > 1 {
		extracted := patternFromField[1]
		if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeRegex
		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeLiteral

		} else if match, _ := regexp.MatchString(AYAYA); match {
			searchType = query.SearchTypeStructural
		}
	}

	return searchType, nil
}

// searchResolver is a resolver for the GraphQL type `Search`
type searchResolver struct {
	query          query.QueryInfo       // the query, either containing and/or expressions or otherwise ordinary
	originalQuery  string                // the raw string of the original search query
	pagination     *searchPaginationInfo // pagination information, or nil if the request is not paginated.
	patternType    query.SearchType
	versionContext *string

	// Cached resolveRepositories results.
	reposMu                   sync.Mutex
	repoRevs, missingRepoRevs []*search.RepositoryRevisions
	excludedRepos             *excludedRepos
	repoOverLimit             bool
	repoErr                   error

	zoekt        *searchbackend.Zoekt
	searcherURLs *endpoint.Map
}

// rawQuery returns the original query string input.
func (AYAYA) rawQuery(AYAYA) string {
	return r.originalQuery
}

func (AYAYA) countIsSet(AYAYA) bool {
	count, _ := r.query.StringValues(AYAYA)
	max, _ := r.query.StringValues(AYAYA)
	return len(AYAYA) > 0 || len(AYAYA) > 0
}

const defaultMaxSearchResults = 30
const maxSearchResultsPerPaginatedRequest = 5000

func (AYAYA) maxResults(AYAYA) int32 {
	if r.pagination != nil {
		// Paginated search requests always consume an entire result set for a
		// given repository, so we do not want any limit here. See
		// search_pagination.go for details on why this is necessary .
		return math.MaxInt32
	}
	count, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	max, _ := r.query.StringValues(AYAYA)
	if len(AYAYA) > 0 {
		n, _ := strconv.Atoi(AYAYA)
		if n > 0 {
			return int32(AYAYA)
		}
	}
	return defaultMaxSearchResults
}

var mockDecodedViewerFinalSettings *schema.Settings

func decodedViewerFinalSettings(AYAYA) (AYAYA) {
	if mockDecodedViewerFinalSettings != nil {
		return mockDecodedViewerFinalSettings, nil
	}
	merged, err := viewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	var settings schema.Settings
	if err := json.Unmarshal(AYAYA); err != nil {
		return nil, err
	}
	return &settings, nil
}

var mockResolveRepoGroups func(AYAYA) (AYAYA)

func resolveRepoGroups(AYAYA) (AYAYA) {
	if mockResolveRepoGroups != nil {
		return mockResolveRepoGroups(AYAYA)
	}

	groups := map[string][]*types.Repo{}

	// Repo groups can be defined in the search.repoGroups settings field.
	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, err
	}
	for name, repoPaths := range settings.SearchRepositoryGroups {
		repos := make(AYAYA)
		for i, repoPath := range repoPaths {
			repos[i] = &types.Repo{Name: api.RepoName(AYAYA)}
		}
		groups[name] = repos
	}

	return groups, nil
}

// NOTE: This function is not called if the version context is not used
func resolveVersionContext(AYAYA) (AYAYA) {
	for _, vc := range conf.Get(AYAYA).ExperimentalFeatures.VersionContexts {
		if vc.Name == versionContext {
			return vc, nil
		}
	}

	return nil, errors.New(AYAYA)
}

// Cf. golang/go/src/regexp/syntax/parse.go.
const regexpFlags regexpsyntax.Flags = regexpsyntax.ClassNL | regexpsyntax.PerlX | regexpsyntax.UnicodeGroups

// exactlyOneRepo returns whether exactly one repo: literal field is specified and
// delineated by regex anchors ^ and $. This function helps determine whether we
// should return results for a single repo regardless of whether it is a fork or
// archive.
func exactlyOneRepo(AYAYA) bool {
	if len(AYAYA) == 1 {
		filter, _ := search.ParseRepositoryRevisions(AYAYA)
		if strings.HasPrefix(AYAYA) && strings.HasSuffix(AYAYA) {
			filter := strings.TrimSuffix(AYAYA)
			r, err := regexpsyntax.Parse(AYAYA)
			if err != nil {
				return false
			}
			return r.Op == regexpsyntax.OpLiteral
		}
	}
	return false
}

// A type that counts how many repos with a certain label were excluded from search results.
type excludedRepos struct {
	forks    int
	archived int
}

// computeExcludedRepositories returns a list of excluded repositories (forks or
// archives) based on the search query.
func computeExcludedRepositories(AYAYA) (AYAYA) {
	if q == nil {
		return &excludedRepos{}
	}
	var err error
	var numExcludedForks, numExcludedArchived int
	forkStr, _ := q.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) {
		// 'fork:...' was not specified and forks are excluded, find out
		// which repos are excluded.
		selectForks := op
		selectForks.OnlyForks = true
		selectForks.NoForks = false
		numExcludedForks, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	archivedStr, _ := q.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) {
		// archived...: was not specified and archives are excluded,
		// find out which repos are excluded.
		selectArchived := op
		selectArchived.OnlyArchived = true
		selectArchived.NoArchived = false
		numExcludedArchived, err = db.Repos.Count(AYAYA)
		if err != nil {
			log15.Warn(AYAYA)
		}
	}
	return &excludedRepos{forks: numExcludedForks, archived: numExcludedArchived}
}

// resolveRepositories calls doResolveRepositories, caching the result for the common
// case where effectiveRepoFieldValues == nil.
func (AYAYA) resolveRepositories(AYAYA) (AYAYA) {
	if mockResolveRepositories != nil {
		return mockResolveRepositories(AYAYA)
	}

	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		if err != nil {
			tr.SetError(AYAYA)
		} else {
			tr.LazyPrintf(AYAYA)
		}
		tr.Finish(AYAYA)
	}(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.reposMu.Lock(AYAYA)
		defer r.reposMu.Unlock(AYAYA)
		if r.repoRevs != nil || r.missingRepoRevs != nil || r.excludedRepos != nil || r.repoErr != nil {
			tr.LazyPrintf(AYAYA)
			return r.repoRevs, r.missingRepoRevs, r.excludedRepos, r.repoOverLimit, r.repoErr
		}
	}

	repoFilters, minusRepoFilters := r.query.RegexpPatterns(AYAYA)
	if effectiveRepoFieldValues != nil {
		repoFilters = effectiveRepoFieldValues
	}
	repoGroupFilters, _ := r.query.StringValues(AYAYA)

	settings, err := decodedViewerFinalSettings(AYAYA)
	if err != nil {
		return nil, nil, nil, false, err
	}
	var settingForks, settingArchived bool
	if v := settings.SearchIncludeForks; v != nil {
		settingForks = *v
	}
	if v := settings.SearchIncludeArchived; v != nil {
		settingArchived = *v
	}

	forkStr, _ := r.query.StringValue(AYAYA)
	fork := parseYesNoOnly(AYAYA)
	if fork == Invalid && !exactlyOneRepo(AYAYA) && !settingForks {
		// fork defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes forks
		fork = No
	}

	archivedStr, _ := r.query.StringValue(AYAYA)
	archived := parseYesNoOnly(AYAYA)
	if archived == Invalid && !exactlyOneRepo(AYAYA) && !settingArchived {
		// archived defaults to No unless either of:
		// (1) exactly one repo is being searched, or
		// (2) user/org/global setting includes archives in all searches
		archived = No
	}

	visibilityStr, _ := r.query.StringValue(AYAYA)
	visibility := query.ParseVisibility(AYAYA)

	commitAfter, _ := r.query.StringValue(AYAYA)

	var versionContextName string
	if r.versionContext != nil {
		versionContextName = *r.versionContext
	}

	tr.LazyPrintf(AYAYA)
	options := resolveRepoOp{
		repoFilters:        repoFilters,
		minusRepoFilters:   minusRepoFilters,
		repoGroupFilters:   repoGroupFilters,
		versionContextName: versionContextName,
		onlyForks:          fork == Only || fork == True,
		noForks:            fork == No || fork == False,
		onlyArchived:       archived == Only || archived == True,
		noArchived:         archived == No || archived == False,
		onlyPrivate:        visibility == query.Private,
		onlyPublic:         visibility == query.Public,
		commitAfter:        commitAfter,
		query:              r.query,
	}
	repoRevs, missingRepoRevs, overLimit, excludedRepos, err = resolveRepositories(AYAYA)
	tr.LazyPrintf(AYAYA)
	if effectiveRepoFieldValues == nil {
		r.repoRevs = repoRevs
		r.missingRepoRevs = missingRepoRevs
		r.excludedRepos = excludedRepos
		r.repoOverLimit = overLimit
		r.repoErr = err
	}
	return repoRevs, missingRepoRevs, excludedRepos, overLimit, err
}

// a patternRevspec maps an include pattern to a list of revisions
// for repos matching that pattern. "map" in this case does not mean
// an actual map, because we want regexp matches, not identity matches.
type patternRevspec struct {
	includePattern *regexp.Regexp
	revs           []search.RevisionSpecifier
}

// given a repo name, determine whether it matched any patterns for which we have
// revspecs (or ref globs), and if so, return the matching/allowed ones.
func getRevsForMatchedRepo(AYAYA) (AYAYA) {
	revLists := make(AYAYA)
	for _, rev := range pats {
		if rev.includePattern.MatchString(AYAYA) {
			revLists = append(AYAYA)
		}
	}
	// exactly one match: we accept that list
	if len(AYAYA) == 1 {
		matched = revLists[0]
		return
	}
	// no matches: we generate a dummy list containing only master
	if len(AYAYA) == 0 {
		matched = []search.RevisionSpecifier{{RevSpec: ""}}
		return
	}
	// if two repo specs match, and both provided non-empty rev lists,
	// we want their intersection
	allowedRevs := make(AYAYA)
	allRevs := make(AYAYA)
	// starting point: everything is "true" if it is currently allowed
	for _, rev := range revLists[0] {
		allowedRevs[rev] = struct{}{}
		allRevs[rev] = struct{}{}
	}
	// in theory, "master-by-default" entries won't even be participating
	// in this.
	for _, revList := range revLists[1:] {
		restrictedRevs := make(AYAYA)
		for _, rev := range revList {
			allRevs[rev] = struct{}{}
			if _, ok := allowedRevs[rev]; ok {
				restrictedRevs[rev] = struct{}{}
			}
		}
		allowedRevs = restrictedRevs
	}
	if len(AYAYA) > 0 {
		matched = make(AYAYA)
		for rev := range allowedRevs {
			matched = append(AYAYA)
		}
		sort.Slice(AYAYA)
		return
	}
	// build a list of the revspecs which broke this, return it
	// as the "clashing" list.
	clashing = make(AYAYA)
	for rev := range allRevs {
		clashing = append(AYAYA)
	}
	// ensure that lists are always returned in sorted order.
	sort.Slice(AYAYA)
	return
}

// findPatternRevs mutates the given list of include patterns to
// be a raw list of the repository name patterns we want, separating
// out their revision specs, if any.
func findPatternRevs(AYAYA) (AYAYA) {
	includePatternRevs = make(AYAYA)
	for i, includePattern := range includePatterns {
		repoPattern, revs := search.ParseRepositoryRevisions(AYAYA)
		// Validate pattern now so the error message is more recognizable to the
		// user
		if _, err := regexp.Compile(AYAYA); err != nil {
			return nil, &badRequestError{err}
		}
		repoPattern = optimizeRepoPatternWithHeuristics(AYAYA)
		includePatterns[i] = repoPattern
		if len(AYAYA) > 0 {
			p, err := regexp.Compile(AYAYA)
			if err != nil {
				return nil, &badRequestError{err}
			}
			patternRev := patternRevspec{includePattern: p, revs: revs}
			includePatternRevs = append(AYAYA)
		}
	}
	return
}

type resolveRepoOp struct {
	repoFilters        []string
	minusRepoFilters   []string
	repoGroupFilters   []string
	versionContextName string
	noForks            bool
	onlyForks          bool
	noArchived         bool
	onlyArchived       bool
	commitAfter        string
	onlyPrivate        bool
	onlyPublic         bool
	query              query.QueryInfo
}

func resolveRepositories(AYAYA) (AYAYA) {
	tr, ctx := trace.New(AYAYA)
	defer func(AYAYA) {
		tr.SetError(AYAYA)
		tr.Finish(AYAYA)
	}(AYAYA)

	includePatterns := op.repoFilters
	if includePatterns != nil {
		// Copy to avoid race condition.
		includePatterns = append(AYAYA)
	}

	excludePatterns := op.minusRepoFilters

	maxRepoListSize := maxReposToSearch(AYAYA)

	// If any repo groups are specified, take the intersection of the repo
	// groups and the set of repos specified with repo:. (If none are specified
	// with repo:, then include all from the group.)
	if groupNames := op.repoGroupFilters; len(AYAYA) > 0 {
		groups, err := resolveRepoGroups(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
		var patterns []string
		for _, groupName := range groupNames {
			for _, repo := range groups[groupName] {
				patterns = append(AYAYA)
			}
		}
		includePatterns = append(AYAYA)

		// Ensure we don't omit any repos explicitly included via a repo group.
		if len(AYAYA) > maxRepoListSize {
			maxRepoListSize = len(AYAYA)
		}
	}

	// note that this mutates the strings in includePatterns, stripping their
	// revision specs, if they had any.
	includePatternRevs, err := findPatternRevs(AYAYA)
	if err != nil {
		return nil, nil, false, nil, err
	}

	// If a version context is specified, gather the list of repository names
	// to limit the results to these repositories.
	var versionContextRepositories []string
	var versionContext *schema.VersionContext
	// If a ref is specified we skip using version contexts.
	if len(AYAYA) == 0 && op.versionContextName != "" {
		versionContext, err = resolveVersionContext(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}

		for _, revision := range versionContext.Revisions {
			versionContextRepositories = append(AYAYA)
		}
	}

	var defaultRepos []*types.Repo
	if envvar.SourcegraphDotComMode(AYAYA) && len(AYAYA) == 0 {
		getIndexedRepos := func(AYAYA) (AYAYA) {
			return zoektIndexedRepos(AYAYA)
		}
		defaultRepos, err = defaultRepositories(AYAYA)
		if err != nil {
			return nil, nil, false, nil, errors.Wrap(AYAYA)
		}
	}

	var repos []*types.Repo
	if len(AYAYA) > 0 {
		repos = defaultRepos
		if len(AYAYA) > maxRepoListSize {
			repos = repos[:maxRepoListSize]
		}
	} else {
		tr.LazyPrintf(AYAYA)
		options := db.ReposListOptions{
			OnlyRepoIDs:     true,
			IncludePatterns: includePatterns,
			Names:           versionContextRepositories,
			ExcludePattern:  unionRegExps(AYAYA),
			// List N+1 repos so we can see if there are repos omitted due to our repo limit.
			LimitOffset:  &db.LimitOffset{Limit: maxRepoListSize + 1},
			NoForks:      op.noForks,
			OnlyForks:    op.onlyForks,
			NoArchived:   op.noArchived,
			OnlyArchived: op.onlyArchived,
			NoPrivate:    op.onlyPublic,
			OnlyPrivate:  op.onlyPrivate,
		}
		excludedRepos = computeExcludedRepositories(AYAYA)
		repos, err = db.Repos.List(AYAYA)
		tr.LazyPrintf(AYAYA)
		if err != nil {
			return nil, nil, false, nil, err
		}
	}
	overLimit = len(AYAYA) >= maxRepoListSize

	repoRevisions = make(AYAYA)
	tr.LazyPrintf(AYAYA)

	for _, repo := range repos {
		var repoRev search.RepositoryRevisions
		var revs []search.RevisionSpecifier
		// versionContext will be nil if the query contains revision specifiers
		if versionContext != nil {
			for _, vcRepoRev := range versionContext.Revisions {
				if vcRepoRev.Repo == string(AYAYA) {
					repoRev.Repo = repo
					revs = append(AYAYA)
				}
			}
		} else {
			var clashingRevs []search.RevisionSpecifier
			revs, clashingRevs = getRevsForMatchedRepo(AYAYA)
			repoRev.Repo = repo
			// if multiple specified revisions clash, report this usefully:
			if len(AYAYA) == 0 && clashingRevs != nil {
				missingRepoRevisions = append(AYAYA)
			}
		}

		// We do in place filtering to reduce allocations. Common path is no
		// filtering of revs.
		if len(AYAYA) > 0 {
			repoRev.Revs = revs[:0]
		}

		// Check if the repository actually has the revisions that the user specified.
		for _, rev := range revs {
			if rev.RefGlob != "" || rev.ExcludeRefGlob != "" {
				// Do not validate ref patterns. A ref pattern matching 0 refs is not necessarily
				// invalid, so it's not clear what validation would even mean.
			} else if isDefaultBranch := rev.RevSpec == ""; !isDefaultBranch { // skip default branch resolution to save time
				// Validate the revspec.

				// Do not trigger a repo-updater lookup (e.g.,
				// backend.{GitRepo,Repos.ResolveRev}) because that would slow this operation
				// down by a lot (if we're looping over many repos). This means that it'll fail if a
				// repo is not on gitserver.
				//
				// TODO(sqs): make this NOT send gitserver this revspec in EnsureRevision, to avoid
				// searches like "repo:@foobar" (where foobar is an invalid revspec on most repos)
				// taking a long time because they all ask gitserver to try to fetch from the remote
				// repo.
				if _, err := git.ResolveRevision(AYAYA); gitserver.IsRevisionNotFound(AYAYA) || err == context.DeadlineExceeded {
					// The revspec does not exist, so don't include it, and report that it's missing.
					if rev.RevSpec == "" {
						// Report as HEAD not "" (empty string) to avoid user confusion.
						rev.RevSpec = "HEAD"
					}
					missingRepoRevisions = append(AYAYA)
					continue
				}
				// If err != nil and is not one of the err values checked for above, cloning and other errors will be handled later, so just ignore an error
				// if there is one.
			}

			repoRev.Revs = append(AYAYA)
		}

		repoRevisions = append(AYAYA)
	}

	tr.LazyPrintf(AYAYA)

	if op.commitAfter != "" {
		repoRevisions, err = filterRepoHasCommitAfter(AYAYA)
	}

	return repoRevisions, missingRepoRevisions, overLimit, excludedRepos, err
}

type indexedReposFunc func(AYAYA) (AYAYA)
type defaultReposFunc func(AYAYA) (AYAYA)

func defaultRepositories(AYAYA) (AYAYA) {
	// Get the list of default repos from the db.
	defaultRepos, err := getRawDefaultRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}

	// Remove excluded repos
	if len(AYAYA) > 0 {
		patterns, _ := regexp.Compile(AYAYA)
		filteredRepos := defaultRepos[:0]
		for _, repo := range defaultRepos {
			if matched := patterns.MatchString(AYAYA); !matched {
				filteredRepos = append(AYAYA)
			}
		}
		defaultRepos = filteredRepos
	}

	// Find out which of the default repos have been indexed.
	defaultRepoRevs := make(AYAYA)
	for _, r := range defaultRepos {
		rr := &search.RepositoryRevisions{
			Repo: r,
			Revs: []search.RevisionSpecifier{{RevSpec: ""}},
		}
		defaultRepoRevs = append(AYAYA)
	}

	indexed, unindexed, err := getIndexedRepos(AYAYA)
	if err != nil {
		return nil, errors.Wrap(AYAYA)
	}
	// If any are unindexed, log the first few so we can find out if something is going wrong with those.
	if len(AYAYA) > 0 {
		N := len(AYAYA)
		if N > 10 {
			N = 10
		}
		var names []string
		for i := 0; i < N; i++ {
			names = append(AYAYA)
		}
		log15.Info(AYAYA)
	}
	// Exclude any that aren't indexed.
	indexedMap := make(AYAYA)
	for _, r := range indexed {
		indexedMap[r.Repo.ID] = true
	}
	defaultRepos2 := make(AYAYA)
	for _, r := range defaultRepos {
		if indexedMap[r.ID] {
			defaultRepos2 = append(AYAYA)
		}
	}
	return defaultRepos2, nil
}

func filterRepoHasCommitAfter(AYAYA) (AYAYA) {
	var (AYAYA)

	goroutine.Go(AYAYA)

	for _, revs := range revisions {
		run.Acquire(AYAYA)

		revs := revs
		goroutine.Go(AYAYA)
	}

	err := run.Wait(AYAYA)
	close(AYAYA)

	return pass, err
}

func optimizeRepoPatternWithHeuristics(AYAYA) string {
	if envvar.SourcegraphDotComMode(AYAYA) && strings.HasPrefix(AYAYA) {
		repoPattern = "^" + repoPattern
	}
	// Optimization: make the "." in "github.com" a literal dot
	// so that the regexp can be optimized more effectively.
	repoPattern = strings.Replace(AYAYA)
	return repoPattern
}

func (AYAYA) suggestFilePaths(AYAYA) (AYAYA) {
	repos, _, _, overLimit, err := r.resolveRepositories(AYAYA)
	if err != nil {
		return nil, err
	}

	if overLimit {
		// If we've exceeded the repo limit, then we may miss files from repos we care
		// about, so don't bother searching filenames at all.
		return nil, nil
	}

	p, err := r.getPatternInfo(AYAYA)
	if err != nil {
		return nil, err
	}
	args := search.TextParameters{
		PatternInfo:     p,
		Repos:           repos,
		Query:           r.query,
		UseFullDeadline: r.searchTimeoutFieldSet(AYAYA),
		Zoekt:           r.zoekt,
		SearcherURLs:    r.searcherURLs,
	}
	if err := args.PatternInfo.Validate(AYAYA); err != nil {
		return nil, err
	}

	fileResults, _, err := searchFilesInRepos(AYAYA)
	if err != nil {
		return nil, err
	}

	var suggestions []*searchSuggestionResolver
	for i, result := range fileResults {
		assumedScore := len(AYAYA) - i // Greater score is first, so we inverse the index.
		suggestions = append(AYAYA)
	}
	return suggestions, nil
}

// SearchRepos searches for the provided query but only the the unique list of
// repositories belonging to the search results.
// It's used by campaigns to search.
func SearchRepos(AYAYA) (AYAYA) {
	queryString := query.ConvertToLiteral(AYAYA)

	var queryInfo query.QueryInfo
	var err error
	if conf.AndOrQueryEnabled(AYAYA) {
		andOrQuery, err := query.ParseAndOr(AYAYA)
		if err != nil {
			return nil, err
		}
		queryInfo = &query.AndOrQuery{Query: andOrQuery}
	} else {
		queryInfo, err = query.ParseAndCheck(AYAYA)
		if err != nil {
			return nil, err
		}
	}

	sr := &searchResolver{
		query:         queryInfo,
		originalQuery: plainQuery,
		pagination:    nil,
		patternType:   query.SearchTypeLiteral,
		zoekt:         search.Indexed(AYAYA),
		searcherURLs:  search.SearcherURLs(AYAYA),
	}

	results, err := sr.Results(AYAYA)
	if err != nil {
		return nil, err
	}
	return results.Repositories(AYAYA), nil
}

func unionRegExps(AYAYA) string {
	if len(AYAYA) == 0 {
		return ""
	}
	if len(AYAYA) == 1 {
		return patterns[0]
	}

	// We only need to wrap the pattern in parentheses if it contains a "|" because
	// "|" has the lowest precedence of any operator.
	patterns2 := make(AYAYA)
	for i, p := range patterns {
		if strings.Contains(AYAYA) {
			p = "(" + p + ")"
		}
		patterns2[i] = p
	}
	return strings.Join(AYAYA)
}

type badRequestError struct {
	err error
}

func (AYAYA) BadRequest(AYAYA) bool {
	return true
}

func (AYAYA) Error(AYAYA) string {
	return "bad request: " + e.err.Error(AYAYA)
}

func (AYAYA) Cause(AYAYA) error {
	return e.err
}

// searchSuggestionResolver is a resolver for the GraphQL union type `SearchSuggestion`
type searchSuggestionResolver struct {
	// result is either a RepositoryResolver or a GitTreeEntryResolver
	result interface{}
	// score defines how well this item matches the query for sorting purposes
	score int
	// length holds the length of the item name as a second sorting criterium
	length int
	// label to sort alphabetically by when all else is equal.
	label string
}

func (AYAYA) ToRepository(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToFile(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

func (AYAYA) ToGitBlob(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsRegular(AYAYA)
}

func (AYAYA) ToGitTree(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok && res.stat.Mode(AYAYA).IsDir(AYAYA)
}

func (AYAYA) ToSymbol(AYAYA) (AYAYA) {
	s, ok := r.result.(AYAYA)
	if !ok {
		return nil, false
	}
	return toSymbolResolver(AYAYA), true
}

func (AYAYA) ToLanguage(AYAYA) (AYAYA) {
	res, ok := r.result.(AYAYA)
	return res, ok
}

// newSearchSuggestionResolver returns a new searchSuggestionResolver wrapping the
// given result.
//
// A panic occurs if the type of result is not a *RepositoryResolver, *GitTreeEntryResolver,
// *searchSymbolResult or *languageResolver.
func newSearchSuggestionResolver(AYAYA) *searchSuggestionResolver {
	switch r := result.(AYAYA) {
	case *RepositoryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: string(AYAYA)}

	case *GitTreeEntryResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Path(AYAYA)}

	case *searchSymbolResult:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.symbol.Name + " " + r.symbol.Parent}

	case *languageResolver:
		return &searchSuggestionResolver{result: r, score: score, length: len(AYAYA), label: r.Name(AYAYA)}

	default:
		panic(AYAYA)
	}
}

func sortSearchSuggestions(AYAYA) {
	sort.Slice(AYAYA)
}

// handleRepoSearchResult handles the limitHit and searchErr returned by a search function,
// updating common as to reflect that new information. If searchErr is a fatal error,
// it returns a non-nil error; otherwise, if searchErr == nil or a non-fatal error, it returns a
// nil error.
func handleRepoSearchResult(AYAYA) (AYAYA) {
	common.limitHit = common.limitHit || limitHit
	if vcs.IsRepoNotExist(AYAYA) {
		if vcs.IsCloneInProgress(AYAYA) {
			common.cloning = append(AYAYA)
		} else {
			common.missing = append(AYAYA)
		}
	} else if gitserver.IsRevisionNotFound(AYAYA) {
		if len(AYAYA) == 0 || len(AYAYA) == 1 && repoRev.Revs[0].RevSpec == "" {
			// If we didn't specify an input revision, then the repo is empty and can be ignored.
		} else {
			return searchErr
		}
	} else if errcode.IsNotFound(AYAYA) {
		common.missing = append(AYAYA)
	} else if errcode.IsTimeout(AYAYA) || errcode.IsTemporary(AYAYA) || timedOut {
		common.timedout = append(AYAYA)
	} else if searchErr != nil {
		return searchErr
	}
	return nil
}

var errMultipleRevsNotSupported = errors.New(AYAYA)



